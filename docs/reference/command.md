<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# command

```go
import "github.com/IMBotPlatform/IMBotCore/pkg/command"
```

## Index

- [Variables](<#variables>)
- [func WithExecutionContext\(ctx context.Context, execCtx \*ExecutionContext\) context.Context](<#WithExecutionContext>)
- [type CommandFactory](<#CommandFactory>)
- [type ContextValues](<#ContextValues>)
- [type ConversationStore](<#ConversationStore>)
- [type ExecutionContext](<#ExecutionContext>)
  - [func FromContext\(ctx context.Context\) \*ExecutionContext](<#FromContext>)
  - [func \(ctx \*ExecutionContext\) ConversationKey\(\) string](<#ExecutionContext.ConversationKey>)
  - [func \(ctx \*ExecutionContext\) Responder\(\) botcore.ActiveResponder](<#ExecutionContext.Responder>)
  - [func \(ctx \*ExecutionContext\) SetNoResponse\(\)](<#ExecutionContext.SetNoResponse>)
  - [func \(ctx \*ExecutionContext\) SetResponsePayload\(payload interface\{\}\)](<#ExecutionContext.SetResponsePayload>)
- [type Manager](<#Manager>)
  - [func NewManager\(factory CommandFactory, store ConversationStore, opts ...ManagerOption\) \*Manager](<#NewManager>)
  - [func \(m \*Manager\) Trigger\(update botcore.Update, streamID string\) \<\-chan botcore.StreamChunk](<#Manager.Trigger>)
- [type ManagerOption](<#ManagerOption>)
  - [func WithLogger\(l \*log.Logger\) ManagerOption](<#WithLogger>)
  - [func WithResponder\(r botcore.ActiveResponder\) ManagerOption](<#WithResponder>)
- [type MemoryStore](<#MemoryStore>)
  - [func NewMemoryStore\(\) \*MemoryStore](<#NewMemoryStore>)
  - [func \(s \*MemoryStore\) Load\(key string\) \(ContextValues, error\)](<#MemoryStore.Load>)
  - [func \(s \*MemoryStore\) Save\(key string, values ContextValues\) error](<#MemoryStore.Save>)
- [type ParseResult](<#ParseResult>)
- [type Parser](<#Parser>)
  - [func NewParser\(\) Parser](<#NewParser>)
  - [func \(p Parser\) Parse\(text string\) ParseResult](<#Parser.Parse>)
- [type StreamWriter](<#StreamWriter>)
  - [func NewStreamWriter\(ch chan\<\- botcore.StreamChunk\) \*StreamWriter](<#NewStreamWriter>)
  - [func \(w \*StreamWriter\) Write\(p \[\]byte\) \(n int, err error\)](<#StreamWriter.Write>)


## Variables

<a name="ErrCommandNotFound"></a>定义命令解析与分发阶段的通用错误，便于统一处理提示文案。

```go
var (
    // ErrCommandNotFound 表示输入命令在注册表中不存在。
    ErrCommandNotFound = errors.New("command not found")
    // ErrCommandRequired 表示未提供任何命令关键字。
    ErrCommandRequired = errors.New("command required")
)
```

<a name="WithExecutionContext"></a>
## func WithExecutionContext

```go
func WithExecutionContext(ctx context.Context, execCtx *ExecutionContext) context.Context
```

WithExecutionContext 将 ExecutionContext 注入到标准 context.Context 中。

<a name="CommandFactory"></a>
## type CommandFactory

CommandFactory 定义创建 Cobra 命令树的工厂函数类型。 在 HTTP 服务中，每个请求必须拥有独立的命令对象实例，以避免 Flag 解析的并发冲突。

```go
type CommandFactory func() *cobra.Command
```

<a name="ContextValues"></a>
## type ContextValues

ContextValues 存储命令执行过程中的上下文扩展字段。

```go
type ContextValues map[string]string
```

<a name="ConversationStore"></a>
## type ConversationStore

ConversationStore 定义上下文存取接口，便于替换实现。

```go
type ConversationStore interface {
    Load(key string) (ContextValues, error)
    Save(key string, values ContextValues) error
}
```

<a name="ExecutionContext"></a>
## type ExecutionContext

ExecutionContext 为命令 handler 提供必要的环境信息。

```go
type ExecutionContext struct {
    Update   botcore.Update
    StreamID string
    Values   ContextValues
    Store    ConversationStore
    // contains filtered or unexported fields
}
```

<a name="FromContext"></a>
### func FromContext

```go
func FromContext(ctx context.Context) *ExecutionContext
```

FromContext 从标准 context.Context 中提取 ExecutionContext。

<a name="ExecutionContext.ConversationKey"></a>
### func \(\*ExecutionContext\) ConversationKey

```go
func (ctx *ExecutionContext) ConversationKey() string
```

ConversationKey 返回当前上下文在存储中的唯一 key。

<a name="ExecutionContext.Responder"></a>
### func \(\*ExecutionContext\) Responder

```go
func (ctx *ExecutionContext) Responder() botcore.ActiveResponder
```

Responder 返回主动消息发送器。

<a name="ExecutionContext.SetNoResponse"></a>
### func \(\*ExecutionContext\) SetNoResponse

```go
func (ctx *ExecutionContext) SetNoResponse()
```

SetNoResponse 立即发送静默信号。 Bot 层收到此信号后将直接返回 HTTP 200 OK 空包。

<a name="ExecutionContext.SetResponsePayload"></a>
### func \(\*ExecutionContext\) SetResponsePayload

```go
func (ctx *ExecutionContext) SetResponsePayload(payload interface{})
```

SetResponsePayload 立即发送非流式响应对象。

<a name="Manager"></a>
## type Manager

Manager 实现 PipelineInvoker，负责串联解析、构建 Cobra 命令树并执行。

```go
type Manager struct {
    // contains filtered or unexported fields
}
```

<a name="NewManager"></a>
### func NewManager

```go
func NewManager(factory CommandFactory, store ConversationStore, opts ...ManagerOption) *Manager
```

NewManager 绑定命令工厂与存储，返回实现 PipelineInvoker 的管理器。

<a name="Manager.Trigger"></a>
### func \(\*Manager\) Trigger

```go
func (m *Manager) Trigger(update botcore.Update, streamID string) <-chan botcore.StreamChunk
```

Trigger 满足 botcore.PipelineInvoker，为每个请求构建独立的命令树并执行。

<a name="ManagerOption"></a>
## type ManagerOption

ManagerOption 自定义 Manager 行为。

```go
type ManagerOption func(*Manager)
```

<a name="WithLogger"></a>
### func WithLogger

```go
func WithLogger(l *log.Logger) ManagerOption
```

WithLogger 注入自定义日志记录器。

<a name="WithResponder"></a>
### func WithResponder

```go
func WithResponder(r botcore.ActiveResponder) ManagerOption
```

WithResponder 注入主动消息发送器。

<a name="MemoryStore"></a>
## type MemoryStore

MemoryStore 提供简单的基于内存的上下文存储实现。 仅用于命令执行期的上下文键值（非聊天历史）；进程重启即丢失。

```go
type MemoryStore struct {
    // contains filtered or unexported fields
}
```

<a name="NewMemoryStore"></a>
### func NewMemoryStore

```go
func NewMemoryStore() *MemoryStore
```

NewMemoryStore 创建内存存储实例。

<a name="MemoryStore.Load"></a>
### func \(\*MemoryStore\) Load

```go
func (s *MemoryStore) Load(key string) (ContextValues, error)
```

Load 返回指定 key 的上下文副本。

<a name="MemoryStore.Save"></a>
### func \(\*MemoryStore\) Save

```go
func (s *MemoryStore) Save(key string, values ContextValues) error
```

Save 合并并存储上下文增量。

<a name="ParseResult"></a>
## type ParseResult

ParseResult 承载文本命令解析后的结构化结果。

```go
type ParseResult struct {
    IsCommand   bool     // 是否检测到命令前缀
    Tokens      []string // 解析后的命令及参数 token（包含命令本身）
    Raw         string   // 原始输入文本
    ArgumentRaw string   // 去除命令后的原始参数串
}
```

<a name="Parser"></a>
## type Parser

Parser 解析企业微信文本内容，判定是否命令并拆分 token。

```go
type Parser struct {
    Prefix string // 命令前缀，默认 "/"
}
```

<a name="NewParser"></a>
### func NewParser

```go
func NewParser() Parser
```

NewParser 创建带默认前缀的解析器。

<a name="Parser.Parse"></a>
### func \(Parser\) Parse

```go
func (p Parser) Parse(text string) ParseResult
```

Parse 将文本拆解为命令 token。规则参考 Telegram Message.IsCommand。

<a name="StreamWriter"></a>
## type StreamWriter

StreamWriter 实现 io.Writer 接口，将输出重定向到 StreamChunk 通道。 这允许 Cobra 命令像操作 stdout 一样直接打印，而结果会被流式传输给用户。

```go
type StreamWriter struct {
    Ch chan<- botcore.StreamChunk
}
```

<a name="NewStreamWriter"></a>
### func NewStreamWriter

```go
func NewStreamWriter(ch chan<- botcore.StreamChunk) *StreamWriter
```

NewStreamWriter 创建一个新的 StreamWriter。

<a name="StreamWriter.Write"></a>
### func \(\*StreamWriter\) Write

```go
func (w *StreamWriter) Write(p []byte) (n int, err error)
```

Write 将字节切片转换为 StreamChunk 发送。

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
