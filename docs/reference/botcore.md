<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# botcore

```go
import "github.com/IMBotPlatform/IMBotCore/pkg/botcore"
```

## Index

- [Variables](<#variables>)
- [type ActiveResponder](<#ActiveResponder>)
- [type Adapter](<#Adapter>)
- [type AdapterFunc](<#AdapterFunc>)
  - [func \(f AdapterFunc\) Normalize\(raw interface\{\}\) \(Update, error\)](<#AdapterFunc.Normalize>)
- [type Chain](<#Chain>)
  - [func NewChain\(defaultHandler Handler\) \*Chain](<#NewChain>)
  - [func \(c \*Chain\) AddRoute\(name string, matcher Matcher, handler Handler\)](<#Chain.AddRoute>)
  - [func \(c \*Chain\) Trigger\(update Update, streamID string\) \<\-chan StreamChunk](<#Chain.Trigger>)
- [type Emitter](<#Emitter>)
- [type EmitterFunc](<#EmitterFunc>)
  - [func \(f EmitterFunc\) Encode\(update Update, streamID string, chunk StreamChunk\) \(interface\{\}, error\)](<#EmitterFunc.Encode>)
- [type Handler](<#Handler>)
- [type Matcher](<#Matcher>)
  - [func MatchAny\(\) Matcher](<#MatchAny>)
  - [func MatchPrefix\(prefix string\) Matcher](<#MatchPrefix>)
- [type PipelineFunc](<#PipelineFunc>)
  - [func \(f PipelineFunc\) Trigger\(update Update, streamID string\) \<\-chan StreamChunk](<#PipelineFunc.Trigger>)
- [type PipelineInvoker](<#PipelineInvoker>)
- [type Route](<#Route>)
- [type StreamChunk](<#StreamChunk>)
- [type Update](<#Update>)
  - [func \(u Update\) CloneMetadata\(\) map\[string\]string](<#Update.CloneMetadata>)


## Variables

<a name="NoResponse"></a>NoResponse 是一个哨兵值，用于标记不需要被动回复。 当 StreamChunk.Payload == NoResponse 时，Bot 层应直接返回 HTTP 200 OK 空包。

```go
var NoResponse = struct{}{}
```

<a name="ActiveResponder"></a>
## type ActiveResponder

ActiveResponder 定义主动发送消息的能力。 接口设计为支持通用和特定类型的发送，方便使用。

```go
type ActiveResponder interface {
    Send(responseURL string, msg interface{}) error
    SendMarkdown(responseURL, content string) error
    SendTemplateCard(responseURL string, card interface{}) error
}
```

<a name="Adapter"></a>
## type Adapter

Adapter 将平台原始消息映射为标准 Update。

```go
type Adapter interface {
    Normalize(raw interface{}) (Update, error)
}
```

<a name="AdapterFunc"></a>
## type AdapterFunc

AdapterFunc 允许直接以函数形式实现 Adapter。

```go
type AdapterFunc func(raw interface{}) (Update, error)
```

<a name="AdapterFunc.Normalize"></a>
### func \(AdapterFunc\) Normalize

```go
func (f AdapterFunc) Normalize(raw interface{}) (Update, error)
```

Normalize 实现 Adapter 接口。

<a name="Chain"></a>
## type Chain

Chain 实现了一个基于责任链/路由表的 PipelineInvoker。 它按顺序检查路由，一旦匹配成功，就移交给对应的 Handler，并停止后续匹配。 如果所有路由都不匹配，且设置了 DefaultHandler，则调用 DefaultHandler。

```go
type Chain struct {
    // contains filtered or unexported fields
}
```

<a name="NewChain"></a>
### func NewChain

```go
func NewChain(defaultHandler Handler) *Chain
```

NewChain 创建一个新的责任链路由器。

<a name="Chain.AddRoute"></a>
### func \(\*Chain\) AddRoute

```go
func (c *Chain) AddRoute(name string, matcher Matcher, handler Handler)
```

AddRoute 添加一条路由规则。

<a name="Chain.Trigger"></a>
### func \(\*Chain\) Trigger

```go
func (c *Chain) Trigger(update Update, streamID string) <-chan StreamChunk
```

Trigger 实现 PipelineInvoker 接口。

<a name="Emitter"></a>
## type Emitter

Emitter 将流水线产生的流式片段转换为平台可用的响应。

```go
type Emitter interface {
    Encode(update Update, streamID string, chunk StreamChunk) (interface{}, error)
}
```

<a name="EmitterFunc"></a>
## type EmitterFunc

EmitterFunc 允许直接用函数实现。

```go
type EmitterFunc func(update Update, streamID string, chunk StreamChunk) (interface{}, error)
```

<a name="EmitterFunc.Encode"></a>
### func \(EmitterFunc\) Encode

```go
func (f EmitterFunc) Encode(update Update, streamID string, chunk StreamChunk) (interface{}, error)
```

Encode 实现 Emitter 接口。

<a name="Handler"></a>
## type Handler

Handler 定义路由处理逻辑。 实际上就是 PipelineInvoker，为了语义清晰起见定义别名。

```go
type Handler PipelineInvoker
```

<a name="Matcher"></a>
## type Matcher

Matcher 定义路由匹配逻辑。 返回 true 表示该路由应该处理此 Update。

```go
type Matcher func(update Update) bool
```

<a name="MatchAny"></a>
### func MatchAny

```go
func MatchAny() Matcher
```

MatchAny 返回一个总是匹配的 Matcher。

<a name="MatchPrefix"></a>
### func MatchPrefix

```go
func MatchPrefix(prefix string) Matcher
```

MatchPrefix 返回一个匹配文本前缀的 Matcher。

<a name="PipelineFunc"></a>
## type PipelineFunc

PipelineFunc 便于直接以函数充当 PipelineInvoker。

```go
type PipelineFunc func(update Update, streamID string) <-chan StreamChunk
```

<a name="PipelineFunc.Trigger"></a>
### func \(PipelineFunc\) Trigger

```go
func (f PipelineFunc) Trigger(update Update, streamID string) <-chan StreamChunk
```

Trigger 实现 PipelineInvoker 接口。

<a name="PipelineInvoker"></a>
## type PipelineInvoker

PipelineInvoker 抽象命令/业务执行器。

```go
type PipelineInvoker interface {
    Trigger(update Update, streamID string) <-chan StreamChunk
}
```

<a name="Route"></a>
## type Route

Route 定义单条路由规则。

```go
type Route struct {
    Name    string
    Matcher Matcher
    Handler Handler
}
```

<a name="StreamChunk"></a>
## type StreamChunk

StreamChunk 描述流式输出片段。

```go
type StreamChunk struct {
    Content string
    Payload interface{} // 扩展：支持携带复杂对象（如 TemplateCard），用于非流式回复
    IsFinal bool
}
```

<a name="Update"></a>
## type Update

Update 描述任意聊天/机器人平台上的标准化事件。

```go
type Update struct {
    ID       string            // 平台内的唯一消息或事件 ID
    SenderID string            // 触发用户标识
    ChatID   string            // 会话 ID（群、私聊等）
    ChatType string            // 会话类型，示例：single/chatroom
    Text     string            // 主要文本内容（若适用）
    Raw      interface{}       // 平台原始结构引用，便于 Handler 深度使用
    Metadata map[string]string // 扩展键值，如语言、平台等
}
```

<a name="Update.CloneMetadata"></a>
### func \(Update\) CloneMetadata

```go
func (u Update) CloneMetadata() map[string]string
```

CloneMetadata 返回一份 Metadata 拷贝，防止 Handler 意外修改底层数据。

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
